<?xml version="1.0"?>
<!--
  ============LICENSE_START==========================================
  ONAP Portal
  ===================================================================
  Copyright (C) 2017-2018 AT&T Intellectual Property. All rights reserved.
  ===================================================================
 
  Unless otherwise specified, all software contained herein is licensed
  under the Apache License, Version 2.0 (the "License");
  you may not use this software except in compliance with the License.
  You may obtain a copy of the License at
 
              http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 
  Unless otherwise specified, all documentation contained herein is licensed
  under the Creative Commons License, Attribution 4.0 Intl. (the "License");
  you may not use this documentation except in compliance with the License.
  You may obtain a copy of the License at
 
              https://creativecommons.org/licenses/by/4.0/
 
  Unless required by applicable law or agreed to in writing, documentation
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 
  ============LICENSE_END============================================
 
  
  -->
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<!-- Publishes mappings and queries specific to the ONAP Portal application. -->
<hibernate-mapping package="org.onap.portalapp.portal.domain">

	<!-- multilanguage -->
	<class name="Language" table="fn_language">
		<id name="languageId" column="language_id">
			<generator class="native">
				<param name="sequence"></param>
			</generator>
		</id>
		<property name="languageName" column="language_name" />
		<property name="languageAlias" column="language_alias" />
	</class>
	
	<class name="DisplayText" table="fn_display_text">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence"></param>
			</generator>
		</id>
		
		<property name="languageId" column="language_id" />
		<property name="textId" column="text_id" />
		<property name="label" column="text_label" />
	</class>

	<!-- Widget class mapping details -->
	<class name="Widget" table="FN_WIDGET">
		<id name="id" column="WIDGET_ID">
			<generator class="native">
				<param name="sequence">seq_fn_widget</param>
			</generator>
		</id>
		<property name="width" type="integer">
			<column name="WDG_WIDTH" not-null="true" default="0"></column>
		</property>
		<property name="height" type="integer">
			<column name="WDG_HEIGHT" not-null="true" default="0"></column>
		</property>
		<property name="url" type="string">
			<column name="WDG_URL" not-null="true" default="?"></column>
		</property>
		<property name="name" type="string">
			<column name="WDG_NAME" not-null="true" default="?"></column>
		</property>

		<property name="appId" type="long">
			<column name="APP_ID" not-null="true"></column>
		</property>

	</class>
	
	<class name="EPEndpoint" table="EP_ENDPOINTS">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_endpoint</param>
			</generator>
		</id>
		<property name="name" type="string">
			<column name="url" not-null="true"></column>
		</property>
	</class>
	
	
	<class name="EPEndpointAccount" table="EP_ENDPOINTS_BASIC_AUTH_ACCOUNT">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_endpoints_basic_auth_account</param>
			</generator>
		</id>
		<property name="ep_id" type="long">
			<column name="ep_id"></column>
		</property>
		<property name="account_id" type="long">
			<column name="account_id"></column>
		</property>
	</class>
	
	<class name="WidgetCatalogParameter" table="EP_WIDGET_CATALOG_PARAMETER">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_widget_catalog_parameter</param>
			</generator>
		</id>
		<property name="widgetId" type="long">
			<column name="widget_id"></column>
		</property>
		<property name="userId" type="long">
			<column name="user_id" not-null="true"></column>
		</property>
		<property name="paramId" type="long">
			<column name="param_id" not-null="true"></column>
		</property>

		<property name="user_value" type="string">
			<column name="user_value" not-null="true"></column>
		</property>

	</class>

	<class name="BasicAuthCredentials" table="ep_basic_auth_account">
        <id name="id" column="id">
            <generator class="native">
 				<param name="sequence">seq_ep_basic_auth_account</param>
			</generator>
        </id>
		<property name="applicationName" type="string">
			<column name="ext_app_name" not-null="true" default="?"></column>
		</property>
		<property name="username" type="string">
			<column name="username"></column>
		</property>
 		<property name="password" type="string">
			<column name="password"></column>
		</property>
  		<property name="isActive" type="string">
			<column name="active_yn" not-null="true" default="Y"></column>
		</property>
    </class> 

	<!-- EPUserNotification class mapping details -->
	<class name="EPUserNotification" table="ep_user_notification">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_user_notification</param>
			</generator>
		</id>
		<property name="userId" column="User_ID" />
		<property name="notificationId" column="notification_ID" />
		<property name="viewed" column="is_viewed" />
		<property name="updateTime" column="updated_time" />
	</class>


	<!-- User class mapping details -->
	<class name="EPUser" table="FN_USER">
		<id name="id" column="user_id">
			<generator class="native">
				<param name="sequence">seq_fn_user</param>
			</generator>
		</id>

		<property name="orgId" column="org_id" />
		<property name="managerId" column="manager_id" />
		<property name="firstName" column="first_name" />
		<property name="middleInitial" column="middle_name" />
		<property name="lastName" column="last_name" />
		<property name="phone" column="phone" />
		<property name="fax" column="fax" />
		<property name="cellular" column="cellular" />
		<property name="email" column="email" />
		<property name="addressId" column="address_id" />
		<property name="alertMethodCd" column="alert_method_cd" />

		<property name="address1" column="address_line_1" />
		<property name="address2" column="address_line_2" />
		<property name="city" column="city" />
		<property name="state" column="state_cd" />
		<property name="zipCode" column="zip_code" />
		<property name="country" column="country_cd" />

		<property name="hrid" column="hrid" />
		<property name="orgUserId" column="org_user_id" />
		<property name="orgCode" column="org_code" />
		<property name="loginId" column="login_id" />
		<property name="loginPwd" column="login_pwd" />
		<property name="lastLoginDate" column="last_login_date" type="timestamp" />

		<property name="locationClli" column="location_clli" />
		<property name="orgManagerUserId" column="org_manager_userid" />
		<property name="company" column="company" />
		<property name="department" column="department" />
		<property name="departmentName" column="department_name" />
		<property name="businessUnit" column="business_unit" />
		<property name="businessUnitName" column="business_unit_name" />
		<property name="jobTitle" column="job_title" />
		<property name="siloStatus" column="silo_status" />
		<property name="financialLocCode" column="fin_loc_code" />
		<property name="costCenter" column="cost_center" />

		<property name="active" column="active_yn" type="yes_no" />
		<property name="internal" column="is_internal_yn" type="yes_no" />

		<property name="created" type="timestamp" column="created_date" />
		<property name="modified" type="timestamp" column="modified_date" />

		<property name="createdId" column="created_id" />
		<property name="modifiedId" column="modified_id" />
		<property name="timeZoneId" column="timezone" />
		<property name="systemUser" column="is_system_user" type="yes_no"/>
		<property name="languageId" column="language_id" />

		<set name="EPUserApps" table="FN_USER_ROLE" lazy="false" sort="natural"
			inverse="true">
			<key column="user_id" />
			<one-to-many class="org.onap.portalapp.portal.domain.EPUserApp" />
		</set>

	</class>

	<class name="MicroserviceData" table="ep_microservice">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_microservice</param>
			</generator>
		</id>

		<property name="name" type="string">
			<column name="name" not-null="true" default="?"></column>
		</property>

		<property name="desc" type="string">
			<column name="description" not-null="true" default="?"></column>
		</property>

		<property name="appId" type="long">
			<column name="appId" not-null="true"></column>
		</property>

		<property name="url" type="string">
			<column name="endpoint_url" not-null="true" default="?"></column>
		</property>

		<property name="securityType" type="string">
			<column name="security_type" not-null="true" default="?"></column>
		</property>


		<property name="username" type="string">
			<column name="username" not-null="true" default="?"></column>
		</property>

		<property name="password" type="string">
			<column name="password" not-null="true" default="?"></column>
		</property>

		<property name="active" type="string">
			<column name="active" not-null="true" default="Y"></column>
		</property>
	</class>

	<class name="MicroserviceParameter" table="ep_microservice_parameter">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_microservice_parameter</param>
			</generator>
		</id>

		<property name="serviceId" type="long">
			<column name="service_id" not-null="true"></column>
		</property>

		<property name="para_key" type="string">
			<column name="para_key" not-null="true" default="?"></column>
		</property>

		<property name="para_value" type="string">
			<column name="para_value" not-null="true" default="?"></column>
		</property>
	</class>

	<!-- UserApp class mapping details -->
	<class name="EPUserApp" table="fn_user_role">
		<composite-id>
			<key-property name="userId" type="long">
				<column name="user_id" precision="11" scale="0" />
			</key-property>
			<key-many-to-one name="app"
				class="org.onap.portalapp.portal.domain.EPApp" column="app_id" />
			<key-many-to-one name="role"
				class="org.onap.portalapp.portal.domain.EPRole" column="role_id" />
		</composite-id>
		<property name="priority">
			<column name="priority" default="1" precision="4" scale="0" />
		</property>
	</class>

	<!-- User App class mapping details -->
	<class name="EPApp" table="fn_app">
		<id name="id" column="app_id">
			<generator class="native">
				<param name="sequence">seq_fn_app</param>
			</generator>
		</id>
		<property name="name" type="string">
			<column name="app_name" not-null="true" default="?"></column>
		</property>
		<property name="imageUrl" column="app_image_url" />
		<property name="appDescription" column="app_description" />
		<property name="appNotes" column="app_notes" />
		<property name="landingPage" column="app_url" />
		<property name="alternateLandingPage" column="app_alternate_url" />
		<property name="appRestEndpoint" column="app_rest_endpoint" />
		<property name="mlAppName" type="string">
			<column name="ml_app_name" not-null="true" default="?"></column>
		</property>
		<property name="mlAppAdminId" type="string">
			<column name="ml_app_admin_id" not-null="true" default="?"></column>
		</property>
		<property name="motsId" column="mots_id" />
		<property name="appBasicAuthPassword" type="string">
			<column name="app_password" not-null="true" default="?"></column>
		</property>
		<property name="thumbnail" column="thumbnail" />
		<property name="appBasicAuthUsername" type="string">
			<column name="app_username" not-null="true" default="?"></column>
		</property>
		<property name="open" type="yes_no">
			<column name="open" not-null="true" default="Y"></column>
		</property>
		<property name="enabled" type="yes_no">
			<column name="enabled" not-null="true" default="N"></column>
		</property>
		<property name="uebTopicName" type="string">
			<column name="ueb_topic_name"></column>
		</property>
		<property name="uebKey" type="string">
			<column name="ueb_key"></column>
		</property>
		<property name="uebSecret" type="string">
			<column name="ueb_secret"></column>
		</property>
		<property name="appType" type="integer">
			<column name="app_type"></column>
		</property>
		<property name="rolesInAAF" type="yes_no">
			<column name="auth_central"></column>
		</property>
		<property name="nameSpace" type="string">
			<column name="auth_namespace"></column>
		</property>
		<property name="modeOfIntegration" type="string">
			<column name="mode_of_integration"></column>
		</property>
		<property name="appAck" type="yes_no">
			<column name="ack_app"></column>
		</property>
		<property name="usesCadi" type="yes_no">
			<column name="uses_cadi"></column>
		</property>

		<one-to-one name="contactUs" class="AppContactUs" cascade="save-update"></one-to-one>

	</class>

	<!-- EPUserAppsSortPreference class mapping details -->
	<class name="EPUserAppsSortPreference" table="ep_pers_user_app_sort">
		<id name="id" column="ID">
			<generator class="native">
				<param name="sequence">seq_ep_usrappsrtprf</param>
			</generator>
		</id>
		<property name="userId" column="USER_ID" />
		<property name="sortPref" column="SORT_PREF" />
	</class>

	<!-- EPUserAppsManualSortPreference class mapping details -->
	<class name="EPUserAppsManualSortPreference" table="ep_pers_user_app_man_sort">
		<id name="id" column="ID">
			<generator class="native">
				<param name="sequence">seq_ep_usrmanappsrtprf</param>
			</generator>
		</id>
		<property name="userId" column="user_id"
			unique-key="uk_1_ep_pers_user_app_man_sort" />
		<property name="appId" column="app_id"
			unique-key="uk_1_ep_pers_user_app_man_sort" />
		<property name="appManualSortOrder" column="sort_order" type="int" />
	</class>

	<class name="EPWidgetsManualSortPreference" table="ep_pers_user_widget_placement">
		<id name="id" column="ID">
			<generator class="native">
				<param name="sequence">seq_ep_usrwidgetsrtprf</param>
			</generator>
		</id>
		<property name="userId" column="user_id" />
		<property name="widgetId" column="widget_id" />
		<property name="widgetRow" column="x" />
		<property name="widgetCol" column="y" />
		<property name="widgetHeight" column="height" />
		<property name="widgetWidth" column="width" />
	</class>

	<!-- User Role class mapping details -->
	<class name="EPRole" table="FN_ROLE" >
		<id name="id" column="role_id">
			<generator class="native">
				<param name="sequence">seq_fn_role</param>
			</generator>
		</id>

		<property name="name" column="role_name" />
		<property name="priority" column="priority" />
		<property name="active" column="active_yn" type="yes_no" />
		<!-- 2 lines below may be removed! -->
		<property name="appId" column="APP_ID" />
		<property name="appRoleId" column="APP_ROLE_ID" />
		<!-- 2 lines above may be removed -->

		<set name="roleFunctions" table="FN_ROLE_FUNCTION" lazy="false"
			sort="natural">
			<key column="role_id" />
			<many-to-many column="function_cd"
				class="org.onap.portalsdk.core.domain.RoleFunction" />
		</set>

		<set name="childRoles" table="FN_ROLE_COMPOSITE" lazy="false"
			sort="natural">
			<key column="parent_role_id" />
			<many-to-many column="child_role_id"
				class="org.onap.portalapp.portal.domain.EPRole" />
		</set>

		<set name="parentRoles" table="FN_ROLE_COMPOSITE" lazy="false"
			sort="natural">
			<key column="child_role_id" />
			<many-to-many column="parent_role_id"
				class="org.onap.portalapp.portal.domain.EPRole" />
		</set>

	</class>

	<!-- User App class mapping details -->
	<class name="AppContactUs" table="fn_app_contact_us">
		<id name="id" column="app_id">
			<generator class="foreign">
				<param name="property">app</param>
			</generator>
		</id>
		<property name="url" column="url" />
		<property name="description" column="description" />
		<property name="contactName" column="contact_name" />
		<property name="contactEmail" column="contact_email" />
		<property name="activeYN" column="active_yn" />

		<one-to-one name="app" class="EPApp" constrained="true"></one-to-one>

	</class>

	<!-- Personalization of user app selections -->
	<class name="PersUserAppSelection" table="fn_pers_user_app_sel">
		<id name="id" column="id">
			<generator class="native">
				<param name="property">seq_fn_pers_user_app_sel</param>
			</generator>
		</id>
		<property name="userId" column="user_id" />
		<property name="appId" column="app_id" />
		<property name="statusCode" column="status_cd" />
	</class>

	<!-- EPAppRoleFunction class mapping details -->
	<class name="EPAppRoleFunction" table="ep_app_role_function">
		<id name="id" column="id">
			<generator class="native">
				<param name="property">seq_epp_app_role_func</param>
			</generator>
		</id>
		<property name="roleId" column="role_id"></property>
		<property name="appId" column="app_id"></property>
		<property name="code" column="function_cd"></property>
		<property name="roleAppId" column="role_app_id"></property>
	</class>

	<!-- CentralRoleFunction class mapping details -->
	<class name="CentralV2RoleFunction" table="ep_app_function">
		<composite-id>
			<key-property name="appId" 
				column="app_id" />
			<key-property name="code" 
				column="function_cd" />
		</composite-id>
		<property name="name" column="function_name" />
	</class>

	<class name="PersUserWidgetSelection" table="ep_pers_user_widget_sel">
		<id name="id" column="id">
			<generator class="native">
				<param name="property">seq_ep_pers_user_widget_sel</param>
			</generator>
		</id>
		<property name="userId" column="user_id" />
		<property name="widgetId" column="widget_id" />
		<property name="statusCode" column="status_cd" />
	</class>

	<!-- EPUserAppRolesRequest class mapping details -->
	<class name="EPUserAppRolesRequest" table="ep_user_roles_request">
		<id name="id" column="req_id">
			<generator class="native">
				<param name="sequence">seq_ep_user_role_request</param>
			</generator>
		</id>
		<property name="userId" column="user_id" />
		<property name="appId" column="app_id" />
		<property name="createdDate" column="created_date" type="timestamp" />
		<property name="updatedDate" column="updated_date" type="timestamp" />
		<property name="requestStatus" column="request_status" />

		<set name="epRequestIdDetail" table="ep_user_roles_request_det"
			lazy="false" cascade="save-update, persist" inverse="true" fetch="select">
			<key column="req_id" />
			<one-to-many
				class="org.onap.portalapp.portal.domain.EPUserAppRolesRequestDetail" />
		</set>
	</class>

	<!-- EPUserAppRolesRequestDetail class mapping details -->
	<class name="EPUserAppRolesRequestDetail" table="ep_user_roles_request_det">
		<id name="id" column="id">
			<generator class="native">
				<param name="sequence">seq_ep_user_role_request_det</param>
			</generator>
		</id>
		<property name="reqRoleId" column="requested_role_id" />
		<property name="reqType" column="request_type" />
		<many-to-one name="epRequestIdData" fetch="select"
			class="org.onap.portalapp.portal.domain.EPUserAppRolesRequest">
			<column name="req_id" not-null="true" />
		</many-to-one>
	</class>

	<!-- multilanguage -->
	<query name="queryLanguage">
		<![CDATA[
			from Language
		]]>
	</query>
	
	<query name="displayText">
		<![CDATA[
			from DisplayText where languageId = :language_id
		]]>
	</query>
	
	<query name="queryLanguageByLanguageId">
		<![CDATA[
			from Language where languageId = :language_id
		]]>
	</query>
	
	<query name="getActiveUsersForApp">
		<![CDATA[
			select distinct(u) from EPUser as u inner join fetch u.EPUserApps as apps inner join fetch apps.app as app inner join fetch apps.role as role where app.id = :id and u.active = :active and role.id is not null
		]]>
	</query>

	<!-- show the current user plus related users -->
	<sql-query name="relatedUsers">
		<return-scalar column="org_user_id" type="java.lang.String" />
		<![CDATA[
			select t.org_user_id from (
				select distinct c.org_user_id org_user_id, c.last_login_date from
					(select c.org_user_id, c.last_login_date from
						fn_user_role a,
						(select distinct role_id, app_id from fn_user_role a1, fn_user a2 where a1.user_id = a2.user_id and a2.org_user_id=:userId ) b,
						fn_user c
						where a.ROLE_ID = b.role_id
						and a.APP_ID = b.app_id
						and a.USER_ID = c.user_id
					union
					select org_user_id , last_login_date from fn_user where org_user_id=:userId
					) c
				order by c.last_login_date desc limit 10
			) t	
		]]>
	</sql-query>

	<!-- requires values for named parameters :searchQuery and :userId -->
	<sql-query name="searchPortal">
		<return alias="searchResult"
			class="org.onap.portalapp.portal.ecomp.model.SearchResultItem" />
		<![CDATA[
			select @rn /*'*/:=/*'*/ @rn+1 AS rowId, CATEGORY, NAME, UUID, TARGET from
				( (
				select distinct 'User' CATEGORY, concat(concat(first_name, ' '), last_name) NAME, user_id UUID, org_user_id TARGET
				from fn_user where
				upper( :searchQuery ) != ''
				and (upper(first_name) like upper(CONCAT('%', :searchQuery, '%'))
				or upper(last_name) like upper(CONCAT('%', :searchQuery, '%'))
				or upper(org_user_id) like upper(CONCAT('%', :searchQuery, '%'))
				or 
		        ((first_name LIKE (SELECT concat('%',trim(SUBSTRING(:searchQuery, 1, INSTR(:searchQuery,' '))),'%'))
		        AND
		       last_name LIKE (concat('%',(SELECT(SUBSTRING(:searchQuery, INSTR(:searchQuery,' ')+1, LENGTH(:searchQuery)))),'%')))
		        OR
		       (last_name LIKE (SELECT concat('%',trim(SUBSTRING(:searchQuery, 1, INSTR(:searchQuery,' '))),'%'))
		         AND
		       first_name LIKE (concat('%',(SELECT(SUBSTRING(:searchQuery, INSTR(:searchQuery,' ')+1, LENGTH(:searchQuery)))),'%')))))
				and  upper(active_yn) = 'Y'
				)
				union
				(
				select distinct 'Application' CATEGORY, b1.app_name NAME,
				if (b1.app_type = 2,'false','true') UUID,
				if (a1.app_id is null, if (b1.app_type = 2, b1.APP_URL, ''), a1.APP_URL) TARGET
				from
				(
				select c.*
				from fn_user_role a, fn_user b, fn_app c
				where a.USER_ID = b.user_id
				and upper(b.org_user_id) = upper(  :userId )
				and a.app_id = c.app_id
				and upper(c.APP_NAME) like upper(CONCAT('%', :searchQuery, '%'))
				and upper(c.ENABLED) = 'Y'
				) a1 right outer join
				(select * from fn_app where
				upper(APP_NAME) like upper(CONCAT('%', :searchQuery, '%'))
				and upper(ENABLED) = 'Y') b1
				on a1.APP_ID = b1.app_id
				)
				union
				(
				select distinct 'Menu' CATEGORY, b1.TEXT NAME,
				if (b1.app_type = 2,'false','true') UUID,
				if (a1.menu_id is null , if (b1.app_type = 2, b1.URL, '') , a1.URL ) TARGET
				from
				(select distinct  d.*, e.app_type from fn_user a,
				fn_user_role b, fn_menu_functional_roles c, fn_menu_functional d, fn_app e
				where a.USER_ID = b.user_id
				and b.role_id = c.role_id
				and c.menu_id = d.menu_id
				and upper(a.org_user_id) = upper( :userId )
				and c.APP_ID = e.app_id
				and upper(d.TEXT) like upper(CONCAT('%', :searchQuery, '%'))
				and upper(d.active_yn) = 'Y'
				and upper(e.enabled) = 'Y'
				) a1 right outer join
				(
				select distinct a.*, c.app_type from fn_menu_functional a, fn_menu_functional_roles b, fn_app c
				where active_yn = 'Y'
				and upper(TEXT) like upper(CONCAT('%', :searchQuery, '%'))
				and a.menu_id = b.menu_id
				and b.app_id = c.app_id
				and c.enabled = 'Y'
				) b1
				on a1.menu_id = b1.menu_id
				)
				union
				select distinct CATEGORY, NAME, UUID, TARGET
				from
				(
				(
				select distinct 'Widget' CATEGORY, d.wdg_name NAME,
				d.widget_id UUID,
				d.wdg_desc TARGET
				from fn_user a, fn_user_role b, ep_widget_catalog_role c, ep_widget_catalog d
				where upper(a.org_user_id) = upper( :userId )
				and a.user_id = b.user_id
				and b.role_id = c.role_id
				and c.widget_id = d.widget_id
				and d.all_user_flag<>'Y'
				and (upper(d.wdg_name) like upper(CONCAT('%', :searchQuery, '%')) or upper(d.wdg_desc) like upper(CONCAT('%', :searchQuery, '%')))
				)
				union
				(
				select distinct 'Widget' CATEGORY, d.wdg_name NAME,
				d.widget_id UUID,
				d.wdg_desc TARGET
				from ep_widget_catalog d
				where d.all_user_flag='Y'
				and (upper(d.wdg_name) like upper(CONCAT('%', :searchQuery, '%')) or upper(d.wdg_desc) like upper(CONCAT('%', :searchQuery, '%')))
				)
				union
				(
				select distinct 'Widget' CATEGORY, d.wdg_name NAME,
				d.widget_id UUID,
				d.wdg_desc TARGET
				from fn_user a, fn_user_role b, ep_widget_catalog d
				where upper(a.org_user_id) = upper( :userId )
				and a.user_id = b.user_id
				and b.role_id = 1
				and (upper(d.wdg_name) like upper(CONCAT('%', :searchQuery, '%')) or upper(d.wdg_desc) like upper(CONCAT('%', :searchQuery, '%')))
				)
				) y
				) t,
				(SELECT @rn /*'*/:=/*'*/ 0) t2 order by NAME
									;

		]]>
	</sql-query>

	<!-- requires values for named parameters :searchQuery and :userId -->
	<sql-query name="getNotifications">
		<return alias="notificationResult"
			class="org.onap.portalapp.portal.transport.EpNotificationItem" />
		<![CDATA[
			select @rn /*'*/:=/*'*/ @rn+1 AS rowId, notification_ID, is_for_online_users,is_for_all_roles, msg_header, msg_description,msg_source, start_Time, end_time, priority, created_date, creator_ID,notification_hyperlink, active_YN from
			( 
			
			select notification_ID, is_for_online_users, is_for_all_roles, msg_header, msg_description, msg_source,start_Time, end_time, priority,created_date, creator_ID,notification_hyperlink,active_YN
			from
				(
				select user_id, notification_id, is_for_online_users, is_for_all_roles, msg_header, msg_description,msg_source,start_Time, end_time, priority, created_date,notification_hyperlink, creator_ID,active_YN
				from
				(
				select a.notification_ID,a.is_for_online_users,a.is_for_all_roles,a.active_YN,
					a.msg_header,a.msg_description,a.msg_source,a.start_time,a.end_time,a.priority,a.creator_ID,a.notification_hyperlink,a.created_date,b.role_id,b.recv_user_id 
				from ep_notification a, ep_role_notification b
				where a.notification_id = b.notification_id
				and (end_time is null ||  SYSDATE() <= end_time )
				and (start_time is null ||  SYSDATE() >= start_time)
				and a.is_for_all_roles = 'N'
				) a,
				(
				select distinct a.user_id, c.role_id, c.app_id, d.APP_NAME
				from fn_user a, fn_user_role b, fn_role c, fn_app d
				where COALESCE(c.app_id,1) = d.app_id
       			and a.user_id = b.user_id
				and a.user_id = :user_id
				and b.role_id = c.role_id
      			and (d.enabled='Y' or d.app_id=1)
				)b
				where
				(
				a.role_id = b.role_id
				)
				union
				select :user_id, notification_id, is_for_online_users, is_for_all_roles, msg_header, msg_description,msg_source,start_Time, end_time, priority, created_date,notification_hyperlink, creator_ID,active_YN
				from
				(
				select a.notification_ID,a.is_for_online_users,a.is_for_all_roles,a.active_YN,
					a.msg_header,a.msg_description,a.msg_source,a.start_time,a.end_time,a.priority,a.creator_ID,a.created_date, a.notification_hyperlink,b.role_id,b.recv_user_id 
				from ep_notification a, ep_role_notification b
				where a.notification_id = b.notification_id
				and (end_time is null ||  SYSDATE() <= end_time )
				and (start_time is null ||  SYSDATE() >= start_time)
				and a.is_for_all_roles = 'N'
				) a
				where
				(
				a.recv_user_id=:user_id
				)
				union
				(
				select :user_id user_id, notification_id, is_for_online_users, is_for_all_roles, msg_header, msg_description, msg_source,start_Time, end_time, priority, created_date,notification_hyperlink, creator_ID,active_YN
				from ep_notification a
				where a.notification_id
				and (end_time is null ||  SYSDATE() <= end_time )
				and (start_time is null ||  SYSDATE() >= start_time)
				and a.is_for_all_roles = 'Y'
				)
				) a
				where
					active_YN = 'Y'
				and
					not exists
				(
				select ID,User_ID,notification_ID,is_viewed,updated_time from ep_user_notification m where user_id = :user_id and m.notification_id = a.notification_id and is_viewed = 'Y'
				)
				order by priority desc, created_date desc,start_Time desc
			
			
			 ) t,
			(SELECT @rn /*'*/:=/*'*/ 0) t2
			;
		]]>

	</sql-query>
		<sql-query name="getUsersByOrgIdsNotifications">
		<return alias="getUsersByOrgIdsNotificationsResult" class="org.onap.portalapp.portal.domain.EPUser"/>
		<![CDATA[
			SELECT * from fn_user where org_user_id in (:OrgIds)
		]]>
		
	</sql-query>
	

	<!-- Gets all Admin notification history; accepts no parameters -->
	<sql-query name="getAdminNotificationHistoryVO">
		<return alias="adminNotificationHistoryVOResult"
			class="org.onap.portalapp.portal.transport.EpNotificationItemVO" /> 
		<![CDATA[
		SELECT * from (
SELECT 
			n.notification_ID AS notificationId, 
			n.is_for_online_users AS isForOnlineUsers, 
			n.is_for_all_roles AS isForAllRoles,
			n.active_YN AS activeYn,			
			n.msg_header AS msgHeader, 
			n.msg_description AS msgDescription, 
			n.msg_source AS msgSource, 
			n.start_Time AS startTime, 
			n.end_time AS endTime, 
			n.priority,
			n.creator_ID AS creatorId,
			n.created_date AS createdDate, 
			n.notification_hyperlink AS notificationHyperlink,
			u.org_user_id AS loginId
		FROM 
			ep_notification n 
		LEFT JOIN
			fn_user u on u.user_id = n.creator_id 
		WHERE
			n.active_YN='Y' and msg_source='EP' 
      
      UNION
      
      SELECT 
			n.notification_ID AS notificationId, 
			n.is_for_online_users AS isForOnlineUsers, 
			n.is_for_all_roles AS isForAllRoles,
			n.active_YN AS activeYn,			
			n.msg_header AS msgHeader, 
			n.msg_description AS msgDescription, 
			n.msg_source AS msgSource, 
			n.start_Time AS startTime, 
			n.end_time AS endTime, 
			n.priority,
			n.creator_ID AS creatorId,
			n.created_date AS createdDate, 
			n.notification_hyperlink AS notificationHyperlink,
			u.org_user_id AS loginId
		FROM 
			ep_notification n 
		LEFT JOIN
			fn_user u on u.user_id = n.creator_id 
    JOIN
			ep_role_notification r on r.notification_ID=n.notification_ID 
		WHERE
			n.active_YN='Y' and r.recv_user_id = :user_id and msg_source!='EP'
      )n order by n.startTime desc
		]]>
	</sql-query>

	<sql-query name="getEpNotificationAppRoles">
		<return alias="notificationAppRoles"
			class="org.onap.portalapp.portal.domain.EcompAppRole" />
		<!-- This query requires no parameters. -->
		<![CDATA[

select  a.app_id, a.app_name, b.role_id, b.role_name from
(select * from fn_app where app_id = 1) a,
(select * from fn_role where app_id is null and active_yn = 'Y' and role_id <> 1) b
union
select fn_role.app_id,fn_app.app_name, fn_role.role_id ,fn_role.role_name
from fn_app, fn_role
where fn_role.app_id = fn_app.app_id and fn_app.enabled='Y' and fn_role.active_yn='Y' order by app_name



		]]>
	</sql-query>

	<!-- Gets all notification history -->
	<sql-query name="getNotificationHistoryVO">
		<return alias="notificationHistoryVOResult"
			class="org.onap.portalapp.portal.transport.EpNotificationItemVO" />
		<![CDATA[
		SELECT
			notificationId, isForOnlineUsers, isForAllRoles, msgHeader,	msgDescription,msgSource,
			startTime, endTime, priority, createdDate,notificationHyperlink,creatorId, loginId,	activeYn 
		FROM
			(
					select distinct 
					a.notification_ID AS notificationId, 
					is_for_online_users AS isForOnlineUsers, 
					is_for_all_roles AS isForAllRoles, 
					msg_header AS msgHeader, 
					msg_description AS msgDescription,
					msg_source AS msgSource,  
					start_Time AS startTime, 
					end_time AS endTime, 
					priority,
					created_date AS createdDate, 
					creator_ID AS creatorId,
					notification_hyperlink AS notificationHyperlink,
					login_id AS loginId,
					active_YN AS activeYn, 
					if (is_viewed is null, 'N', is_viewed)
			from
			(
				select 
					user_id, login_id,notification_id, is_for_online_users, is_for_all_roles, 
					msg_header, msg_description,msg_source, start_Time, end_time, priority, created_date, 
					creator_ID,notification_hyperlink,active_YN
				from
				(
					select a.notification_ID,a.is_for_online_users,a.is_for_all_roles,a.active_YN,
					a.msg_header,a.msg_description,a.msg_source,a.start_time,a.end_time,a.priority,a.creator_ID,a.notification_hyperlink,a.created_date, 
					 b.role_id,CASE WHEN a.creator_ID IS NOT NULL THEN u.org_user_id
                   
                   ELSE NULL
              END  AS login_id,b.recv_user_id 
				from ep_notification a, ep_role_notification b,fn_user u
				where a.notification_id = b.notification_id and  (u.user_id=a.creator_ID OR a.creator_ID IS NULL)
				and a.is_for_all_roles = 'N'
				and (
				(start_time is null and end_time is null and a.created_date >= DATE_ADD(curdate(),INTERVAL-31 DAY))
				or
				(start_time is not null and end_time is null and start_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is not null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				)
				) a,
				(
				select distinct a.user_id, c.role_id, c.app_id, d.APP_NAME
				from fn_user a, fn_user_role b, fn_role c, fn_app d
				where COALESCE(c.app_id,1) = d.app_id
        		and a.user_id = b.user_id
				and a.user_id = :user_id
				and b.role_id = c.role_id
      			and (d.enabled='Y' or d.app_id=1)
				) b
				where
				(
				a.role_id = b.role_id
				)
				   UNION
        		select 
					:user_id, login_id,notification_id, is_for_online_users, is_for_all_roles, 
					msg_header, msg_description,msg_source, start_Time, end_time, priority, created_date, 
					creator_ID,notification_hyperlink,active_YN
				from
				(
					select a.notification_ID,a.is_for_online_users,a.is_for_all_roles,a.active_YN,
					a.msg_header,a.msg_description,a.msg_source,a.start_time,a.end_time,a.priority,a.creator_ID,a.created_date,a.notification_hyperlink, 
					 b.role_id,CASE WHEN a.creator_ID IS NOT NULL THEN u.org_user_id
                   
                   ELSE NULL
              END  AS login_id,b.recv_user_id 
				from ep_notification a, ep_role_notification b,fn_user u
				where a.notification_id = b.notification_id and  (u.user_id=a.creator_ID OR a.creator_ID IS NULL)
				and a.is_for_all_roles = 'N'
				and (
				(start_time is null and end_time is null and a.created_date >= DATE_ADD(curdate(),INTERVAL-31 DAY))
				or
				(start_time is not null and end_time is null and start_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is not null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				)
				) a
		        where
		        (
		        a.recv_user_id=:user_id
		        )
				union
				(
				select 
					:user_id user_id, b.login_id,notification_id, is_for_online_users, is_for_all_roles,
					msg_header, msg_description,msg_source, start_Time, end_time, priority, a.created_date, 
					creator_ID, a.notification_hyperlink,a.active_YN
				from ep_notification a  JOIN fn_user b on b.user_id=a.creator_ID
				where a.notification_id
				and a.is_for_all_roles = 'Y'
				and (
				(start_time is null and end_time is null and a.created_date >= DATE_ADD(curdate(),INTERVAL-31 DAY))
				or
				(start_time is not null and end_time is null and start_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				or
				(start_time is not null and end_time is not null and end_time >= DATE_ADD(curdate(),INTERVAL  -31 DAY))
				)
				)
				) a left outer join (
				select m.notification_ID, m.is_viewed from ep_user_notification m where user_id = :user_id
				) m
				on  a.notification_id = m.notification_ID
				where
				active_YN = 'Y'
				
				order by  start_Time desc,end_time desc
			) t,
                     (SELECT @rn /*'*/:=/*'*/ 0) t2 where startTime<=SYSDATE() 
		]]>

	</sql-query>
	
		<!-- shows the received recipient to whom the notification is delivered from external system -->
	<sql-query name="messageRecipients">
		<return-scalar column="org_user_id" type="java.lang.String" />
		<![CDATA[
			select u.org_user_id from ep_notification n join ep_role_notification r on r.notification_ID=n.notification_ID join fn_user u on u.user_id=r.recv_user_id where n.notification_id=:notificationId
		]]>
	</sql-query>
	

	<!-- Gets role details for a specified notification -->
	<sql-query name="getNotificationRoles">
		<return alias="notificationRolesResult"
			class="org.onap.portalapp.portal.transport.EpRoleNotificationItem" />
		<![CDATA[
			SELECT * 
 			FROM
				ep_role_notification 
			WHERE
				notification_Id = :notificationId
		]]>
	</sql-query>

	<!-- Gets all applications, possibly with contact information -->
	<sql-query name="getAppsAndContacts">
		<return alias="appContactUs"
			class="org.onap.portalapp.portal.ecomp.model.AppContactUsItem" />
		<!-- This query requires no parameters. -->
		<![CDATA[
			select 
				a.app_id as appId, a.app_name as appName,
				c.contact_name as contactName, 
				c.contact_email as contactEmail, c.url, c.description, 
				c.active_yn as activeYN
			from 
				fn_app a
			left join 
				fn_app_contact_us c
				on a.app_id = c.app_id
			where 
				a.enabled = 'Y' and a.app_name is not null and a.app_name != ''
			;
		]]>
	</sql-query>

	<!-- Gets all rows from the app-contact-us table, extended with app information -->
	<sql-query name="getAppContactUsItems">
		<return alias="appContactUs"
			class="org.onap.portalapp.portal.ecomp.model.AppContactUsItem" />
		<!-- This query requires no parameters. -->
		<![CDATA[
			select 
				c.app_id as appId, c.contact_name as contactName, 
				c.contact_email as contactEmail, c.url, c.description, 
				c.active_yn as activeYN, a.app_name as appName
			from 
				fn_app_contact_us c
			left join 
				fn_app a
				on a.app_id = c.app_id
			where 
				a.enabled = 'Y' and a.app_name is not null and a.app_name != ''
			;
		]]>
	</sql-query>

	<!-- Gets one row for each app with the category and catenated functions. -->
	<sql-query name="getAppCategoryFunctions">
		<return alias="appCategoryFunctions"
			class="org.onap.portalapp.portal.ecomp.model.AppCategoryFunctionsItem" />
		<!-- This query requires no parameters. -->
		<![CDATA[
			SELECT @rn /*'*/:=/*'*/ @rn+1 AS rowId,
				r.category as category, r.app_id as appId, r.app_name as application, 
				group_concat(function_text separator ', ') as functions
			FROM ( 
				SELECT 
				app_id, function_text, app_name,
				IF (a.parent_menu_id IS NULL, fn.parent_menu, a.text) category 
				FROM ( 
					SELECT 
					j.text function_text, j.menu_id function_id, j.app_id app_id, j.app_name app_name, 
					k.text parent_menu, k.parent_menu_id parent_menu_id 
					FROM ( 
						SELECT distinct 
						x.Text, x.PARENT_MENU_ID, x.menu_id, y.app_id, z.app_name 
						FROM 
						fn_menu_functional x, fn_menu_functional_roles y, fn_app z 
						WHERE 
						x.MENU_ID = y.menu_id AND x.ACTIVE_YN = 'Y' AND y.app_id = z.app_id 
						) j,
					fn_menu_functional k 
					WHERE j.parent_menu_id = k.menu_id 
					) fn, 
				fn_menu_functional a 
				WHERE fn.parent_menu_id = a.menu_id 
			) r, 
			(SELECT @rn /*'*/:=/*'*/ 0) t2 
			group by r.category, r.app_id, r.app_name 
			order by category, app_name 
			;
		]]>
	</sql-query>

	<!-- Gets one row for each function-application-role combination. -->
	<sql-query name="getAppAccessFunctionRole">
		<return alias="appAccessFunctionRole"
			class="org.onap.portalapp.portal.domain.GetAccessResult" />
		<!-- This query requires one parameters. -->
		<![CDATA[
			select @rn /*'*/:=/*'*/ @rn+1 AS row_id, t.role_id, t.ECOMP_FUNCTION, t.APP_NAME, t.APP_MOTS_ID, t.ROLE_NAME,
			(select (case when fur.role_id is not null then 'Y' end) from fn_user_role fur where fur.user_id =:userId and fur.role_id = t.role_id and fur.app_id = t.app_id) as role_actv,
			o.requested_role_id,o.request_type
			from
			(select ECOMP_FUNCTION, APP_NAME, APP_MOTS_ID, ROLE_NAME ,a.app_id,a.role_id
			from
			(
			select D.APP_NAME, D.MOTS_ID APP_MOTS_ID, C.ROLE_NAME, d.app_id , c.role_id
			from
			FN_ROLE C, FN_APP D
			where COALESCE(c.app_id,1) = d.app_id
			and (d.enabled='Y' or d.app_id=1)
			and c.active_yn = 'Y'
			) a left outer join
			(
			select A.TEXT ECOMP_FUNCTION, b.role_id, b.app_id from fn_menu_functional A, fn_menu_functional_roles B
			WHERE
			A.MENU_ID = B.MENU_ID
			and active_yn = 'Y'
			)b
			on a.role_id = b.role_id) t left outer join
			(select ed.requested_role_id, er.app_id ,ed.request_type from ep_user_roles_request er , ep_user_roles_request_det ed
			where er.req_id=ed.req_id
			and upper(ed.request_type)='P'
			and er.user_id =:userId) o
			on t.app_id=o.app_id
			and t.role_id = o.requested_role_id
			JOIN (SELECT @rn /*'*/:=/*'*/ 0) p
			;
		]]>
	</sql-query>

	<query name="getCommonWidgetItem">
		from CommonWidget where category = :cat order by
		sortOrder, title
	</query>

	<sql-query name="getGuestLastLogin">
		<return-scalar column="audit_date" type="java.util.Date" />		
		<![CDATA[
			select audit_date from fn_audit_log where affected_record_id =:userId order by audit_date desc limit 2;
		]]>
	</sql-query>
	
	<sql-query name="getActiveUsers">
		<return alias="EPUser" class="org.onap.portalapp.portal.domain.EPUser" />   
		<![CDATA[
    		SELECT * FROM FN_USER WHERE active_yn='Y' 
		]]>
	</sql-query>

	<sql-query name="getAppsAdmins">
		<return alias="adminUserApp" class="org.onap.portalapp.portal.domain.AdminUserApp" />   
	<![CDATA[
    	SELECT apps.APP_NAME, apps.APP_ID, user.USER_ID, user.FIRST_NAME, user.LAST_NAME, user.org_user_id FROM fn_user_role userrole INNER JOIN fn_user user ON user.USER_ID = userrole.USER_ID INNER JOIN fn_app apps ON apps.APP_ID = userrole.APP_ID  WHERE user.active_yn='Y' AND userrole.ROLE_ID = :accountAdminRoleId       
	]]>
	</sql-query>
	
	<sql-query name="getPortalAdmins">
		<return alias="portalAdmin" class="org.onap.portalapp.portal.transport.PortalAdmin" />   
	<![CDATA[
		SELECT u.user_id, u.first_name, u.last_name, u.login_id FROM fn_user u, fn_user_role ur WHERE u.active_yn = 'Y' AND u.user_id = ur.user_id AND ur.role_id= :adminRoleId
	]]>
	</sql-query>
	
	<!-- Gets personalized list of enabled and accessible apps for regular user -->
	<sql-query name="getPersUserApps">
		<return alias="persUserApps" class="org.onap.portalapp.portal.domain.EPApp" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[
		    select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE        , a.AUTH_CENTRAL
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.USER_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
			)
			order by app_name
		    ;
		]]>
	</sql-query>

	<!-- Gets personalized list of enabled and accessible apps for Portal (super) 
		admin -->
	<sql-query name="getPersAdminApps">
		<return alias="persAdminApps" class="org.onap.portalapp.portal.domain.EPApp" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[
		    select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE      , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.ROLE_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
				or
				(a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S')
			)
			order by app_name
		    ;
		]]>
	</sql-query>

	<!-- Gets personalized list of enabled and accessible Admin apps by name -->
	<sql-query name="getPersAdminAppsOrderByName">
		<return alias="AdminAppsOrderByName" class="org.onap.portalapp.portal.domain.EPApp" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[ 
		 select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE          , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.ROLE_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
				or
				(a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S')
			)
			union
		select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d , ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
		  order by app_name
		  ;
		
		]]>
	</sql-query>

	<!--Gets personalized list of enabled and accessible User apps by name -->
	<sql-query name="getPersUserAppsOrderByName">
		<return alias="UserAppsOrderByName" class="org.onap.portalapp.portal.domain.EPApp" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[ 
		select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE         , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.USER_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
			)
			union
		select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d , ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
		order by app_name
		 ;
		
		]]>
	</sql-query>


	<!--Gets personalized list of enabled and accessible Super Admin apps by 
		LastUsed -->
	<sql-query name="getAdminAppsOrderByLastUsed">
		<return alias="AdminAppsOrderByLastUsed" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[
		    select 
			*
			from (select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE          , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.ROLE_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
				or
				(a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S')
			)
			union
		  select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d , ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			) A 
    		left outer join
			(select  FN_AUDIT_LOG.AFFECTED_RECORD_ID, max(FN_AUDIT_LOG.AUDIT_DATE) AS AUDIT_DATE 
			from FN_APP LEFT JOIN FN_AUDIT_LOG 
			on FN_APP.APP_ID = FN_AUDIT_LOG.AFFECTED_RECORD_ID  
			where FN_APP.ENABLED = 'Y' and FN_AUDIT_LOG.user_id=:userId
			and (audit_date) BETWEEN (CURDATE() - INTERVAL 90 DAY) and CURDATE() 
			group by  FN_AUDIT_LOG.AFFECTED_RECORD_ID
			 )B
			on A.app_id = B.Affected_record_id
			order by AUDIT_DATE DESC;
			]]>
	</sql-query>

	<!--Gets personalized list of enabled and accessible User apps by LastUsed -->
	<sql-query name="getUserAppsOrderByLastUsed">
		<return alias="UserAppsOrderByLastUsed" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
			select * from (select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE         , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.USER_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
			)union
		select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d , ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			
			) A 
    		left outer join
			(select  FN_AUDIT_LOG.AFFECTED_RECORD_ID, max(FN_AUDIT_LOG.AUDIT_DATE) AS AUDIT_DATE 
			from FN_APP LEFT JOIN FN_AUDIT_LOG 
			on FN_APP.APP_ID = FN_AUDIT_LOG.AFFECTED_RECORD_ID  
			where FN_APP.ENABLED = 'Y' and FN_AUDIT_LOG.user_id=:userId
			and (audit_date) BETWEEN (CURDATE() - INTERVAL 90 DAY) and CURDATE() 
			group by  FN_AUDIT_LOG.AFFECTED_RECORD_ID 
			 )B
			on A.app_id = B.Affected_record_id
			order by AUDIT_DATE DESC;
		    
			
		]]>

	</sql-query>

	<!--Gets personalized list of enabled and accessible Super Admin apps by 
		Most Used -->
	<sql-query name="getAdminAppsOrderByMostUsed">
		<return alias="AdminAppsOrderByMostUsed" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 		
			select 
			*
			from (select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE         , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.ROLE_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
				or
				(a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S')
			)union
		   select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d , ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			) A 
			left outer join
			(select  FN_AUDIT_LOG.AFFECTED_RECORD_ID, COUNT(*) AS total_visits 
			from FN_APP LEFT JOIN FN_AUDIT_LOG 
			on FN_APP.APP_ID = FN_AUDIT_LOG.AFFECTED_RECORD_ID  
			where FN_APP.ENABLED = 'Y' and FN_AUDIT_LOG.user_id=:userId
			and DATE(audit_date) BETWEEN (CURDATE() - INTERVAL 90 DAY) and CURDATE() 
			group by  FN_AUDIT_LOG.AFFECTED_RECORD_ID 
			 )B
			on A.app_id = B.Affected_record_id
			order by total_visits DESC;
		]]>

	</sql-query>

	<!--Gets personalized list of enabled and accessible NON Super Admin User 
		apps by Most Used -->
	<sql-query name="getUserAppsOrderByMostUsed">
		<return alias="UserAppsOrderByMostUsed" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
			select * from 
			(select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE     	 , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.USER_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
			)union
		  select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d, ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			)A 
			left outer join
			(select  FN_AUDIT_LOG.AFFECTED_RECORD_ID, COUNT(*) AS total_visits 
			from FN_APP LEFT JOIN FN_AUDIT_LOG 
			on FN_APP.APP_ID = FN_AUDIT_LOG.AFFECTED_RECORD_ID  
			where FN_APP.ENABLED = 'Y' and FN_AUDIT_LOG.user_id=:userId
			and DATE(audit_date) BETWEEN (CURDATE() - INTERVAL 90 DAY) and CURDATE() 
			group by  FN_AUDIT_LOG.AFFECTED_RECORD_ID 
			 )B
			on A.app_id = B.Affected_record_id
			order by total_visits DESC;
		]]>
	</sql-query>

	<!--Gets personalized list of enabled and accessible Super Admin apps by 
		Manual -->
	<sql-query name="getAdminAppsOrderByManual">
		<return alias="AdminAppsOrderByManual" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
			select * from 			
			(select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE        , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.ROLE_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
				or
				(a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S')
			)union
		select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d, ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			) A
			left outer join
			 (select m.app_id, m.sort_order 
			from ep_pers_user_app_man_sort m
			where USER_ID = :userId
			) B 
			on A.APP_ID = B.app_id
			order by sort_order ASC
		    ;
		]]>

	</sql-query>

	<!--Gets personalized list of enabled and accessible NON Super admin User 
		apps by Manual -->
	<sql-query name="getUserAppsOrderByManual">
		<return alias="UserAppsOrderByManual" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
							select * from	(select
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID			, a.APP_NAME 		, a.APP_IMAGE_URL  		, a.APP_DESCRIPTION , 
	    		a.APP_NOTES 		, a.APP_URL 		, a.APP_ALTERNATE_URL 	, a.APP_REST_ENDPOINT ,
				a.ML_APP_NAME 		, a.ML_APP_ADMIN_ID , a.MOTS_ID 			, a.APP_PASSWORD ,
    			a.THUMBNAIL 		, a.APP_USERNAME	, a.OPEN 				, a.ENABLED , 
				a.UEB_TOPIC_NAME 	, a.UEB_KEY 		, a.UEB_SECRET 			, a.APP_TYPE        , a.AUTH_CENTRAL ,
				a.AUTH_NAMESPACE
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator		    
			left outer join	FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			where a.ENABLED = 'Y'
		    and (
				(a.OPEN = 'Y' and p.STATUS_CD = 'S')
		        or
				(a.OPEN = 'N' and r.USER_ID is not null and (p.STATUS_CD is null or p.STATUS_CD != 'H'))
			)union
		select distinct  -- multiple roles yield multiple rows
			    b.APP_ID			, b.APP_NAME 		, b.APP_IMAGE_URL  		,b.APP_DESCRIPTION , 
	    		b.APP_NOTES 		, b.APP_URL 		, b.APP_ALTERNATE_URL 	, b.APP_REST_ENDPOINT ,
			   	b.ML_APP_NAME 		, b.ML_APP_ADMIN_ID , b.MOTS_ID 			, b.APP_PASSWORD ,
    			b.THUMBNAIL 		, b.APP_USERNAME	, b.OPEN 				, b.ENABLED , 
          b.UEB_TOPIC_NAME 	, b.UEB_KEY 		, b.UEB_SECRET 			, b.APP_TYPE         , b.AUTH_CENTRAL ,
          b.AUTH_NAMESPACE
          from fn_user_role a, fn_app b, ep_app_role_function c   , fn_role d, ep_app_function e
          where a.user_id =:userId  and b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and a.role_id = d.role_id and e.app_id = c.app_id
			) A
			left outer join
			 (select m.app_id, m.sort_order 
			from ep_pers_user_app_man_sort m
			where USER_ID = :userId
			) B 
			on A.APP_ID = B.app_id
			order by sort_order ASC
		    ;
		]]>
	</sql-query>

	<!-- Gets regular user's list of enabled apps including accessible and select 
		statuses -->
	<sql-query name="getUserAppCatalog">
		<return alias="userAppCatalog"
			class="org.onap.portalapp.portal.ecomp.model.AppCatalogItem" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[
						select 
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID as id, a.APP_NAME as name, a.ML_APP_NAME as mlAppName, a.APP_IMAGE_URL as imageUrl,
			    a.APP_DESCRIPTION as description, a.APP_NOTES as notes,
			    a.APP_URL as url, a.APP_ALTERNATE_URL as alternateUrl,
				IF(a.app_type = '2', TRUE, FALSE) as restricted,
			    IF(a.open = 'Y', TRUE, FALSE) as open,
                -- ACCESS(-ible) means user has a defined role OR the application is open 
				case
					-- regular app and user has a role
					when a.OPEN = 'N' and r.ROLE_ID is not null then TRUE
                    -- open app
                    when a.OPEN = 'Y' then TRUE
                    else FALSE
                end as 'access' ,
                -- SELECT(-ed) indicates user personalization
                case	
					-- regular app, user has a role, no personalization
					when a.OPEN = 'N' and r.ROLE_ID is not null and p.STATUS_CD is null then TRUE
                    -- open app and has personalization
                    when a.OPEN = 'Y' and p.STATUS_CD is not null then TRUE
                    else FALSE
                end as 'select' ,
                -- PENDING indicates user checked a box
                case
                	when a.OPEN = 'N' and  q.request_status = 'P' then TRUE
                	else FALSE
                end as 'pending'
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator
            left outer join FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
      left outer join EP_USER_ROLES_REQUEST q ON a.APP_ID = q.APP_ID and q.USER_ID = :userId and q.request_status = 'P'
      where a.ENABLED = 'Y'
      
			-- Show accessible apps first, then the rest; sort by name within each set.
            order by access desc, app_name asc
		    ;
		]]>
	</sql-query>

	<sql-query name="getMyloginAppDetails">
		<return alias="myloginAppDetails" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
		SELECT * FROM fn_app  where ml_app_name =:appName
		;		
		]]>
	</sql-query>
	
	<sql-query name="getAppDetailsByAppName">
		<return alias="appDetailsByAppName" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
		SELECT * FROM fn_app  where app_name =:appName
		;		
		]]>
	</sql-query>
	
		<sql-query name="getMyAppDetailsByUebKey">
		<return alias="myAppDetailsByUebKey" class="org.onap.portalapp.portal.domain.EPApp" />
		<![CDATA[ 
		SELECT * FROM fn_app  where ueb_key =:appKey
		;		
		]]>
	</sql-query>
	
	
	<sql-query name="deleteAccountEndpoint">
		<![CDATA[ 
		DELETE FROM ep_endpoints_basic_auth_account WHERE account_id =:accountId
		;		
		]]>
	</sql-query>
	
	<sql-query name="deleteAccountEndpointRecord">
		<![CDATA[ 
		DELETE FROM ep_endpoints_basic_auth_account WHERE account_id =:accountId AND ep_id =:epId
		;		
		]]>
	</sql-query>
	
	<sql-query name="deleteEPEndpoint">
		<![CDATA[ 
		DELETE FROM ep_endpoints WHERE id =:epId
		;		
		]]>
	</sql-query>
	
	<sql-query name="deleteBasicAuthAccount">
		<![CDATA[ 
		DELETE FROM ep_basic_auth_account WHERE id =:accountId
		;		
		]]>
	</sql-query>

	<sql-query name="getAppRoles">
		<return alias="appRoles" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where role_name =:roleName and app_id =:appId
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPartnerAppRolesList">
		<return alias="partnerAppRolesList" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where app_id =:appId
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPortalAppRolesList">
		<return alias="portalAppRolesList" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where app_id is null
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPortalAppRoleByRoleId">
		<return alias="portalAppByRoleId" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where role_id =:roleId and app_id is null
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPartnerAppRoleByRoleId">
		<return alias="portalAppByRoleId" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where app_role_id =:appRoleId and app_id =:appId
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPartnerAppRoleById">
		<return alias="portalAppByRoleId" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where role_id =:appRoleId and app_id =:appId
		;		
		]]>
	</sql-query>
	
	<sql-query name="getPortalAppRoles">
		<return alias="appRoles" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		SELECT * FROM fn_role where role_name =:appRoleName and app_id is null
		;		
		]]>
	</sql-query>

	<sql-query name="deleteMicroserviceParameter">
		<![CDATA[ 
		DELETE FROM ep_microservice_parameter WHERE service_id =:serviceId
		;		
		]]>
	</sql-query>
	
	<sql-query name="deleteMicroserviceParameterById">
		<![CDATA[ 
		DELETE FROM ep_microservice_parameter WHERE id =:paramId
		;		
		]]>
	</sql-query>
	
	<sql-query name="deleteWidgetCatalogParameter">
		<![CDATA[ 
		DELETE FROM ep_widget_catalog_parameter WHERE param_id =:paramId
		;		
		]]>
	</sql-query>

	<sql-query name="deleteMicroservice">
		<![CDATA[ 
		DELETE FROM ep_microservice WHERE id =:serviceId
		;		
		]]>
	</sql-query>

	<sql-query name="epUserAppId">
		<return alias="userAppId" class="org.onap.portalapp.portal.domain.EPUser" />
		<![CDATA[ 
		SELECT * FROM  FN_USER  where ORG_USER_ID = :orgUserIdValue
		;		
		]]>
	</sql-query>

	<sql-query name="userAppsSortPreferenceQuery">
		<return alias="appsSortPreferenceQuery"
			class="org.onap.portalapp.portal.domain.EPUserAppsSortPreference" />
		<![CDATA[ 
		SELECT * from  EP_PERS_USER_APP_SORT e where e.USER_ID = :userId
				
		]]>
	</sql-query>

	<sql-query name="userAppsManualSortPrfQuery">
		<return alias="AppsManualSortPrfQuery"
			class="org.onap.portalapp.portal.domain.EPUserAppsManualSortPreference" />
		<![CDATA[ 
		SELECT * from  EP_PERS_USER_APP_MAN_SORT where USER_ID =:userId
				
		]]>
	</sql-query>

	<sql-query name="userWidgetManualSortPrfQuery">
		<return alias="widgetManualSortPrfQuery"
			class="org.onap.portalapp.portal.domain.EPWidgetsManualSortPreference" />
		<![CDATA[ 
		SELECT * from  EP_PERS_USER_WIDGET_PLACEMENT where USER_ID =:userId
		]]>
	</sql-query>

	<sql-query name="appRoles">
		<return alias="rolesForApp"
			class="org.onap.portalapp.portal.domain.EPUserAppRoles" />
		<![CDATA[ 
			SELECT ROLE_ID, APP_ID from FN_ROLE where APP_ROLE_ID = :appRoleId and app_id = :appId
			;
		]]>
	</sql-query>

	<sql-query name="userAppRolesRequestList">
		<return alias="appRolesRequestList"
			class="org.onap.portalapp.portal.domain.EPUserAppRolesRequest" />
		<![CDATA[ 
			SELECT req_id, user_id, app_id, created_date, updated_date, request_status from  EP_USER_ROLES_REQUEST where user_id =:userId and app_id=:appId and request_status = 'P'
			;
		]]>
	</sql-query>

	<sql-query name="userAppRolesRequestDetailList">
		<return alias="appRolesRequestDetailList"
			class="org.onap.portalapp.portal.domain.EPUserAppRolesRequestDetail" />
		<![CDATA[ 
		
			SELECT  id, req_id, requested_role_id, request_type from  EP_USER_ROLES_REQUEST_DET where req_id =:reqId
			;
		]]>
	</sql-query>

	<!-- Gets list of enabled apps including accessible and select statuses -->
	<sql-query name="getAdminAppCatalog">
		<return alias="adminAppCatalog"
			class="org.onap.portalapp.portal.ecomp.model.AppCatalogItem" />
		<!-- This query requires one parameter: userId (number) -->
		<![CDATA[
			select 
				distinct  -- multiple roles yield multiple rows
			    a.APP_ID as id, a.APP_NAME as name, a.ML_APP_NAME as mlAppName, a.APP_IMAGE_URL as imageUrl,
			    a.APP_DESCRIPTION as description, a.APP_NOTES as notes,
			    a.APP_URL as url, a.APP_ALTERNATE_URL as alternateUrl,
				IF(a.app_type = '2', TRUE, FALSE) as restricted,
			    IF(a.open = 'Y', TRUE, FALSE) as open,
                -- ACCESS(-ible) means user has a defined role OR the application is open 
				case
					-- regular app and user has a role
					when a.OPEN = 'N' and r.ROLE_ID is not null then TRUE
                    -- open app
                    when a.OPEN = 'Y' then TRUE
                    else FALSE
                end as 'access' ,
                -- SELECT(-ed) indicates user personalization
                case
					-- regular app, user has a role, no personalization
					when a.OPEN = 'N' and r.ROLE_ID is not null and p.STATUS_CD is null then TRUE
					-- regular app, user has role, admin forced a personalization
					when a.OPEN = 'N' and r.ROLE_ID is not null and p.STATUS_CD = 'S' then TRUE
					-- regular app, user has no role, admin forced a personalization
					when a.OPEN = 'N' and r.ROLE_ID is null and p.STATUS_CD = 'S' then TRUE
                    -- open app and has personalization
                    when a.OPEN = 'Y' and p.STATUS_CD is not null then TRUE
                    else FALSE
                end as 'select' ,
                -- PENDING indicates user checked a box
                case
                	when a.OPEN = 'N' and  q.request_status = 'P' then TRUE
                	else FALSE
                end as 'pending'
		    from FN_APP a
		    -- Portal assigns role 999 to app administrator
            left outer join FN_USER_ROLE         r ON a.APP_ID = r.APP_ID and r.USER_ID = :userId and r.ROLE_ID != 999
			left outer join FN_PERS_USER_APP_SEL p ON a.APP_ID = p.APP_ID and p.USER_ID = :userId
			left outer join EP_USER_ROLES_REQUEST q ON a.APP_ID = q.APP_ID and q.USER_ID = :userId and q.request_status = 'P'
			where a.ENABLED = 'Y'
			-- Show accessible apps first, then the rest; sort by name within each set.
            order by access desc, app_name asc
		    ;
		]]>
	</sql-query>

	<sql-query name="userAppCatalogRoles">
		<return alias="epUserAppCatalogRoles"
			class="org.onap.portalapp.portal.domain.EPUserAppCatalogRoles" />
		<![CDATA[ 
        select  a.req_id, B.requested_role_id ,  A.request_status  , A.app_id , (select role_name from fn_role where role_id = B.requested_role_id) as role_name
       from ep_user_roles_request A left join ep_user_roles_request_det B
		   on a.req_id = b.req_id
		   where  A.user_id=:userid
       and A.app_id IN (select app_id from fn_app where app_name=:appName)
       and A.request_status ='P'
       ;
		]]>
	</sql-query>

	<sql-query name="getUserApproles">
		<return alias="businessCardUserApplicationRoles"
			class="org.onap.portalapp.portal.transport.BusinessCardApplicationRole" />
		<![CDATA[
		
 		select   fr.role_name, fa.app_name 
          from   
        fn_role fr, fn_user_role fur, fn_app fa, fn_user fu  
          Where  fu.user_id =  fur.user_id and fur.role_id = fr.role_id and fa.app_id = fur.app_id and fu.org_user_id = :userId and fr.active_yn='Y' and (fa.enabled = 'Y' or fa.app_id=1)
          ;
 
 		]]>
	</sql-query>
     
    <!--delete the records from ep_notification table when the endtime is more than 3 months-->
	<sql-query name="deleteNotificationsFromEpNotificationTable">
		<![CDATA[
		delete from ep_notification where  curdate() >= DATE_ADD(end_time,INTERVAL 3 MONTH)
		]]>
	</sql-query>


	 	<!-- delete the records from ep_role_notification table when the endtime is more than 3 months -->
	<sql-query name="deleteNotificationsFromEpRoleNotificationTable">
		<![CDATA[
	delete from ep_role_notification where  notification_id in (select notification_id from ep_notification where  curdate() >= DATE_ADD(end_time,INTERVAL 3 MONTH))
		]]>
	</sql-query> 
	
	<!-- delete the records from ep_user_notification table when the endtime is more than 3 months-->
	<sql-query name="deleteNotificationsFromEpUserNotificationTable">
		<![CDATA[
	delete from ep_user_notification where  notification_id in (select notification_id from ep_notification where  curdate() >= DATE_ADD(end_time,INTERVAL 3 MONTH))
		]]>
	</sql-query>
	
	<!-- Gets list of role functions and it requires two parameters appId and roleId-->
	<sql-query name="getAppRoleFunctionList">
		<return alias="appRoleFunctionList"
			class="org.onap.portalapp.portal.domain.CentralV2RoleFunction" />
		<![CDATA[ 
			
			SELECT DISTINCT f.app_id , f.function_cd, f.function_name from ep_app_role_function rf, ep_app_function f  
			where rf.role_id =:roleId and rf.app_id =:appId and rf.app_id = f.app_id and rf.function_cd = f.function_cd
			;
				
		]]>
	</sql-query> 
	
	<!-- Gets list of all role functions -->
	<sql-query name="getAllRoleFunctions">
		<return alias="allRoleFunctions"
			class="org.onap.portalapp.portal.domain.CentralV2RoleFunction" />
		<![CDATA[ 
			
			SELECT * from ep_app_function where app_id =:appId
			;
				
		]]>
	</sql-query>
	
	<!-- Get ep_app_function records provided by single parameter -->
	<sql-query name="getRoleFunction">
		<return alias="RoleFunction"
			class="org.onap.portalapp.portal.domain.CentralV2RoleFunction" />
			<![CDATA[
			
			SELECT * from ep_app_function where function_cd like CONCAT('%', :functionCode,'%') and app_id =:appId
			;
			
			]]>
	</sql-query>
		
	<!-- Gets the current user app roles records and requires two parameters  -->
	<sql-query name="getUserAppCurrentRoles">
		<return alias="userAppCurrentRoles"
			class="org.onap.portalapp.portal.transport.EPUserAppCurrentRoles" />
			<![CDATA[
			
			select distinct fu.role_id, fr.user_id, fu.role_name, fu.priority from fn_role fu left outer join fn_user_role fr ON fu.role_id = fr.role_id and fu.app_id = fr.app_id and fr.role_id != 999 where fu.app_id =:appId and fr.user_id =:userId and fu.active_yn='Y' 
			;		
			]]>
	</sql-query>
	
	<!-- Gets the current user app roles along with account administrator and requires two parameters  -->
	<sql-query name="getUserAppExistingRoles">
		<return alias="userAppExistingRoles"
			class="org.onap.portalapp.portal.transport.EcompUserAppRoles" />
			<![CDATA[
			select fr.role_name, fu.app_id, fu.user_id, fu.priority, fu.role_id from fn_user_role fu 
			left outer join fn_role fr on fu.role_id = fr.role_id 
			where fu.user_id =:userId and fu.app_id =:appId
			;			
			]]>
	</sql-query>
	
	<!-- Gets all functions of portal app -->
	<sql-query name="getAllFunctions">
		<return alias="allFunctions"
			class="org.onap.portalsdk.core.domain.RoleFunction" />
			<![CDATA[	
			select * from fn_function
			;		
			]]>
	</sql-query>
	
	<!-- Gets the current user app roles records and requires two parameters  -->
	<sql-query name="getPartnerAppFunctions">
		<return alias="partnerAppFunctions"
			class="org.onap.portalapp.portal.domain.CentralV2RoleFunction" />
			<![CDATA[	
			select * from ep_app_function where app_id =:appId
			;		
			]]>
	</sql-query>
	
	<!-- Gets the  all role functions and requires one parameters -->
	<sql-query name="uploadAllRoleFunctions">
		<return alias="allRoleFunctions"
			class="org.onap.portalapp.portal.transport.BulkUploadRoleFunction" />
			<![CDATA[	
				select fr.function_cd, fn.function_name from fn_role_function fr left outer join fn_function fn on fr.function_cd = fn.function_cd where role_id =:roleId
				;		
			]]>
	</sql-query>
	
		<!-- Gets the  all application role functions from ep_app_function table and requires one parameters -->
	<sql-query name="uploadPartnerRoleFunctions">
		<return alias="partnerRoleFunctions"
			class="org.onap.portalapp.portal.transport.BulkUploadRoleFunction" />
			<![CDATA[	
				select distinct eprf.function_cd, epfn.function_name from ep_app_role_function eprf left outer join ep_app_function epfn on eprf.function_cd = epfn.function_cd where eprf.role_id =:roleId
				;	
			]]>
	</sql-query>

	<sql-query name="getRoletoUpdateInExternalAuthSystem">
		<return alias="roletoUpdateInExternalAuthSystem" class="org.onap.portalapp.portal.domain.EPRole" />
			<![CDATA[
					SELECT * FROM fn_role where role_name =:appRoleName and app_id =:appId
			;		
			]]>
	</sql-query>
	
		<!-- Gets all active records from fn_role that is associated with this app-->
	<sql-query name="getActiveRolesOfApplication">
		<return alias="activeRolesOfApplication" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[
		select * from fn_role where active_yn = 'Y' and app_id=:appId
		;
 		]]>
	</sql-query>

	<sql-query name="getBulkUserRoles">
		<return alias="bulkUserRoles" class="org.onap.portalapp.portal.transport.BulkUploadUserRoles" />
			<![CDATA[
			select fr.role_name, fu.org_user_id, fa.auth_namespace from fn_user_role fur 
			left outer join fn_role fr on fr.role_id = fur.role_id 
			left outer join fn_app fa on fa.app_id = fur.app_id
			left outer join fn_user fu on fu.user_id = fur.user_id where fa.ueb_key =:uebKey
			;	
			]]>
	</sql-query>
	
	<sql-query name="getBulkUsersForSingleRole">
		<return alias="bulkUsersForSingleRole" class="org.onap.portalapp.portal.transport.BulkUploadUserRoles" />
			<![CDATA[
			select fr.role_name, fu.org_user_id, fa.auth_namespace from fn_user_role fur 
			left outer join fn_role fr on fr.role_id = fur.role_id 
			left outer join fn_app fa on fa.app_id = fur.app_id
			left outer join fn_user fu on fu.user_id = fur.user_id where fa.ueb_key =:uebKey and fr.role_id =:roleId
			;	
			]]>
	</sql-query>
	
	<sql-query name="getCentralizedApps">
		<return alias="centralizedApps" class="org.onap.portalapp.portal.domain.EPApp" />
			<![CDATA[
			select * from fn_app where auth_central = 'Y' and open = 'N' and auth_namespace is not null
			;	
			]]>
	</sql-query>
	
	<sql-query name="getUserRoles">
			<return alias="getUserRolesList" class="org.onap.portalapp.portal.domain.UserRole" />
		<![CDATA[ 
				
        SELECT DISTINCT user.USER_ID, role.ROLE_ID, user.org_user_id, user.FIRST_NAME, user.LAST_NAME, role.ROLE_NAME  FROM fn_user_role userrole INNER JOIN fn_user user ON user.USER_ID = userrole.USER_ID INNER JOIN fn_role role ON role.ROLE_ID = userrole.ROLE_ID WHERE user.org_user_id =:org_user_id and userrole.app_id = 1 
         ;
		]]>
	</sql-query>
		<sql-query name="getRoleFunctionsOfUser">
			<![CDATA[
			select distinct ep.function_cd from fn_user_role fu, ep_app_role_function ep, ep_app_function ea
			where fu.role_id = ep.role_id 
			and fu.app_id = ep.app_id
			and fu.user_id =:userId and ep.app_id = 1
			and ea.function_cd = ep.function_cd
		    union
            select distinct app_r_f.function_cd from ep_app_role_function app_r_f, ep_app_function a_f
			where role_id = 999
			and app_r_f.function_cd = a_f.function_cd
			and exists
			(
			select fa.app_id from fn_user fu, fn_user_role ur, fn_app fa where fu.user_id =:userId and fu.user_id = ur.user_id
			and ur.role_id = 999 and ur.app_id = fa.app_id and fa.enabled = 'Y'
			);
			]]>
	</sql-query>
	
	<sql-query name="getRoleFunctionsOfUserforAlltheApplications">
			<![CDATA[
			select distinct ep.function_cd from fn_user_role fu, ep_app_role_function ep, ep_app_function ea
			where fu.role_id = ep.role_id 
			and fu.app_id = ep.app_id
			and fu.user_id =:userId 
			and ea.function_cd = ep.function_cd
		   	and exists
			(
			select fa.app_id from fn_user fu, fn_user_role ur, fn_app fa where fu.user_id =:userId and fu.user_id = ur.user_id
			and ur.app_id = fa.app_id and fa.enabled = 'Y'
			);
			]]>
	</sql-query>
	
	<sql-query name="getApplicationsofTheUserwithAdminAndRoleAdmin">
	<return alias="getApplicationsofTheUserwithAdminAndRoleAdmin" class="org.onap.portalapp.portal.domain.AppIdAndNameTransportModel" />
			<![CDATA[
			SELECT app.APP_ID, app.APP_NAME, app.APP_TYPE FROM FN_APP app 
			inner join FN_USER_ROLE userrole ON userrole.APP_ID=app.APP_ID 
			where userrole.USER_ID = :userId AND userrole.ROLE_ID=999 AND (app.ENABLED = 'Y' OR app.APP_ID=1)
			UNION
			SELECT DISTINCT app.APP_ID, app.app_name, app.APP_TYPE FROM fn_user user 
					INNER JOIN fn_user_role user_role ON user.USER_ID = user_role.USER_ID 
					 INNER JOIN fn_role role ON role.ROLE_ID = user_role.ROLE_ID  
		        INNER JOIN fn_app app ON app.app_id= user_role.app_id and (app.enabled='Y'  or app.app_id=1) 
		        INNER JOIN ep_app_role_function appfunction ON  appfunction.app_id = app.app_id and appfunction.role_id=role.ROLE_ID and (appfunction.function_cd like '%APPROVER%')
		        WHERE user.user_id = :userId ;
			]]>
	</sql-query>
	
	<sql-query name="getApplicationsofTheUserContainsApprover">
	<return alias="getApplicationsofTheUserContainsApprover" class="org.onap.portalapp.portal.domain.AppIdAndNameTransportModel" />
			<![CDATA[
			SELECT DISTINCT app.APP_ID, app.APP_TYPE, app.app_name FROM fn_user user 
					INNER JOIN fn_user_role user_role ON user.USER_ID = user_role.USER_ID 
					 INNER JOIN fn_role role ON role.ROLE_ID = user_role.ROLE_ID  
		        INNER JOIN fn_app app ON app.app_id= user_role.app_id and (app.enabled='Y'  or app.app_id=1) 
		        INNER JOIN ep_app_role_function appfunction ON  appfunction.app_id = app.app_id and appfunction.role_id=role.ROLE_ID and (appfunction.function_cd like '%APPROVER%')
		        WHERE user.user_id = :userId ;
			]]>
	</sql-query>
	
	
	
	<sql-query name="getUserRolesForLeftMenu">
			<return alias="getUserRolesListForLeftMenu" class="org.onap.portalapp.portal.domain.UserRole" />
	
		<![CDATA[ 
  		SELECT DISTINCT user.USER_ID, role.ROLE_ID, user.org_user_id, user.FIRST_NAME, user.LAST_NAME, role.ROLE_NAME  FROM fn_user_role userrole 
        INNER JOIN fn_user user ON user.USER_ID = userrole.USER_ID 
        INNER JOIN fn_app app ON app.app_id= userrole.app_id
        INNER JOIN fn_role role ON role.ROLE_ID = userrole.ROLE_ID 
        WHERE user.org_user_id =:org_user_id and (userrole.app_id = 1 or role.role_id =   999) and (app.enabled='Y'  or app.app_id=1)
        ;
		]]>
	</sql-query>
	
	<sql-query name="getRolesForLeftMenu">
			<return alias="getUserRolesListForLeftMenu" class="org.onap.portalapp.portal.domain.UserRole" />
	
		<![CDATA[ 
  		SELECT DISTINCT user.USER_ID, role.ROLE_ID, user.org_user_id, user.FIRST_NAME, user.LAST_NAME, role.ROLE_NAME  FROM fn_user_role userrole 
        INNER JOIN fn_user user ON user.USER_ID = userrole.USER_ID 
        INNER JOIN fn_app app ON app.app_id= userrole.app_id
        INNER JOIN fn_role role ON role.ROLE_ID = userrole.ROLE_ID 
        WHERE user.org_user_id =:org_user_id and (userrole.app_id = 1 or role.role_id =   999) and ((app.enabled='Y' and auth_central='Y' ) or app.app_id=1)
        ;
		]]>
	</sql-query>
	
	<!-- Gets all functions for an application along with global functions and requires single parameter -->
	<sql-query name="getMenuFunctions">
		<![CDATA[ 
			select f.function_cd from ep_app_function f
			where f.app_id =:appId
			UNION
			select epa.function_cd from fn_role fnr, ep_app_role_function epr, ep_app_function epa where epr.role_id = fnr.role_id
			and epa.function_cd = epr.function_cd and fnr.role_name like 'global%' and fnr.app_id is null and epr.app_id = 1
		 ;
		]]>
	</sql-query>
	
	<sql-query name="getRequestIdsForApp">
	<return alias="getRequestIdsForApp" class="org.onap.portalapp.portal.domain.EPUserAppRolesRequest" />
		<![CDATA[ 
		select * from ep_user_roles_request where app_id =:app_id
		;
		]]>
	</sql-query>

	<sql-query name="ApplicationUserRoles">
		<return alias="ApplicationUserRoles" class="org.onap.portalapp.portal.transport.EcompUserRoles" />
		<![CDATA[ 
		   select distinct fu.org_id, fu.manager_id, fu.first_name, fu.middle_name, fu.last_name, fu.phone, fu.email, fu.hrid, fu.org_user_id, fu.org_code, fu.org_manager_userid, fu.job_title, fu.login_id, 
           fu.active_yn , fr.app_role_id, fr.role_name, epr.function_cd , epf.function_name
           from fn_user fu, fn_role fr, fn_user_role fur, ep_app_role_function epr , ep_app_function epf
           where fu.user_id = fur.user_id and fu.active_yn='Y' and fur.role_id = fr.role_id and fr.app_id =:appId and fr.active_yn='Y' and epr.function_cd= epf.function_cd and epf.app_id=epr.app_id and fur.role_id=epr.role_id
           union
           select distinct fu.org_id, fu.manager_id, fu.first_name, fu.middle_name, fu.last_name, fu.phone, fu.email, fu.hrid, fu.org_user_id, fu.org_code, fu.org_manager_userid, fu.job_title, 
           fu.login_id, fu.active_yn , fr.role_id, fr.role_name, earf.function_cd , eaf.function_name
           from fn_user_role a, fn_role fr, fn_user fu , ep_app_role_function earf, ep_app_function eaf
           where a.role_id in (select b.role_id from ep_app_role_function b where b.role_app_id = 1 and b.app_id =:appId) and a.user_id =fu.user_id and a.role_id = fr.role_id and fr.active_yn='Y' and fu.active_yn='Y'
           and earf.role_id = a.role_id and earf.function_cd = eaf.function_cd and earf.app_id = eaf.app_id  and earf.role_app_id = 1 and fr.active_yn='Y' and fu.active_yn='Y';
		]]>
	</sql-query>
	
	<sql-query name="getCurrentAppRoleFunctions">
		<return alias="ApplicationUserRoles" class="org.onap.portalapp.portal.transport.LocalRole" />
		<![CDATA[ 
		select distinct fr.role_id, fr.role_name  from fn_role fr, ep_app_function ef, ep_app_role_function epr where fr.role_id = epr.role_id and epr.function_cd = ef.function_cd
 		and ef.function_cd =:functionCd and epr.app_id =:appId
 		;
		]]>
	</sql-query>
	
	<sql-query name="deleteUserWidgetPlacement">
		<![CDATA[ 
		DELETE FROM ep_pers_user_widget_placement WHERE user_id =:userId AND widget_id =:widgetId
		;		
		]]>
	</sql-query>
	
	<sql-query name="getCentralizedAppsOfUser">	
		<return alias="CentralizedAppsForRoles" class="org.onap.portalapp.portal.domain.CentralizedApp" />   	
		<![CDATA[
		
 		select distinct fa.app_id, fa.app_name
		from  fn_role fr, fn_user_role fur, fn_app fa, fn_user fu  
		Where  fu.user_id =  fur.user_id and fur.role_id = fr.role_id and fa.app_id = fur.app_id 
		and fu.org_user_id = :userId and (fur.role_id = 999 or fur.role_id = 1) and fr.active_yn='Y' and ((fa.enabled = 'Y' and fa.auth_central='Y') or fa.app_id =1) 
		;
 
 		]]>
	</sql-query>
	
    <query name="getEPUserByOrgUserId">
	<![CDATA[
		FROM EPUser WHERE orgUserId = :org_user_id
	]]>
    </query>

	<query name="getEPUserByLoginId">
	<![CDATA[
		FROM EPUser WHERE loginId = :login_id
	]]>
    </query>

    <query name="getEPUserByLoginIdLoginPwd">
	<![CDATA[
		FROM EPUser WHERE loginId = :login_id and loginPwd = :login_pwd		
	]]>
    </query>
    
    <sql-query name="getGlobalRoleWithApplicationRoleFunctions">	
		<return alias="getGlobalRoleWithApplicationRoleFunctions" class="org.onap.portalapp.portal.transport.GlobalRoleWithApplicationRoleFunction" />   	
		<![CDATA[
 		select distinct  d.role_id, d.role_name , c.function_cd , e.function_name , d.active_yn , d.priority , c.app_id, c.role_app_id
		from fn_user_role a, fn_app b, ep_app_role_function c , fn_role d , ep_app_function e
		where b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and e.function_cd = c.function_cd and c.app_id= :appId and e.app_id=c.app_id
		;
 		]]>
	</sql-query>
	
     <sql-query name="getGlobalRolesOfPortal">
		<return alias="getGlobalRolesOfPortal" class="org.onap.portalapp.portal.domain.EPRole" />
		<![CDATA[ 
		select * from fn_role where role_name  like 'global_%' and app_id is null and active_yn='Y'
		;		
		]]>
	</sql-query>
	
	<sql-query name="getAppRoleFunctionOnRoleIdandAppId">
		<return alias="appRoleFunctionOnRoleIdandAppId" class="org.onap.portalapp.portal.domain.EPAppRoleFunction" />
		<![CDATA[ 
		select * from ep_app_role_function where app_id =:appId and role_id =:roleId 
		;		
		]]>
	</sql-query>
	
	<sql-query name="getAppFunctionOnCodeAndAppId">
		<return alias="appFunctionOnCodeAndAppId" class="org.onap.portalapp.portal.domain.CentralV2RoleFunction" />
		<![CDATA[ 
		select * from ep_app_function where app_id =:appId and function_cd =:functionCd 
		;		
		]]>
	</sql-query>
	
	<sql-query name="getGlobalRoleForRequestedApp">	
		<return alias="getGlobalRoleForRequestedApp" class="org.onap.portalapp.portal.transport.GlobalRoleWithApplicationRoleFunction" />   	
		<![CDATA[
 		select distinct  d.role_id, d.role_name , c.function_cd , e.function_name , d.active_yn , d.priority , c.app_id, c.role_app_id
        from fn_user_role a, fn_app b, ep_app_role_function c , fn_role d , ep_app_function e
        where b.app_id = c.app_id and a.app_id = c.role_app_id and b.enabled = 'Y' and c.role_id = d.role_id and d.active_yn='Y' and e.function_cd = c.function_cd and c.app_id=:requestedAppId and c.role_id =:roleId and e.app_id = c.app_id
        ;
 		]]>
	</sql-query>
	
	<sql-query name="getBulkUploadPartnerGlobalRoleFunctions">	
		<return alias="bulkUploadPartnerGlobalRoleFunctions" class="org.onap.portalapp.portal.transport.GlobalRoleWithApplicationRoleFunction" />   	
		<![CDATA[
		select distinct fr.role_id, fr.role_name, fr.active_yn, fr.priority, epr.function_cd, ep.function_name, ep.app_id, epr.role_app_id
		from fn_role fr, ep_app_function ep, ep_app_role_function epr
		where fr.role_id = epr.role_id and ep.function_cd = epr.function_cd and ep.app_id = epr.app_id and  epr.app_id = :appId and epr.role_app_id = 1	
		;
		]]>
	</sql-query>
	
	<sql-query name="updateMenuFunctionalAndRoles">	
		<![CDATA[
		  UPDATE fn_menu_functional m, fn_menu_functional_roles mr SET m.url='' WHERE m.menu_id=mr.menu_id AND mr.app_id=:app_id	
 		 ;
 		]]>
	</sql-query>
	
	<!-- Remove any favorites associated with a menu item that is associated with this app -->
	<sql-query name="removeAppFromMenuFavorites">	
		<![CDATA[
		DELETE FROM fn_menu_favorites using fn_menu_favorites inner join fn_menu_functional_roles where fn_menu_functional_roles.app_id=:app_id AND fn_menu_functional_roles.menu_id=fn_menu_favorites.menu_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove all role, appid records from fn_menu_functional_role that is associated with this app -->
	<sql-query name="removeAppFromMenuFunctionalRoles">	
		<![CDATA[
		DELETE FROM fn_menu_functional_roles WHERE app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove all roles, rolefunctions, appid records from ep_app_role_function that is associated with this app -->
	<sql-query name="removeAppFromEpAppRoleFunction">	
		<![CDATA[
		DELETE FROM ep_app_role_function WHERE app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove all rolefunctions, appid records from ep_app_function that is associated with this app -->
	<sql-query name="removeAppFromEpAppFunction">	
		<![CDATA[
		DELETE FROM ep_app_function WHERE app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove all records from fn_user_role associated with this app that is associated with this app -->
	<sql-query name="removeAppFromFnUserRole">	
		<![CDATA[
		DELETE FROM fn_user_role WHERE app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove any widgets that is associated with this app-->
	<sql-query name="removeAppFromEpWidgetCatalogRole">	
		<![CDATA[
		DELETE FROM ep_widget_catalog_role WHERE app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove any notifications that is associated with this app-->
	<sql-query name="removeAppFromEpRoleNotification">	
		<![CDATA[
		DELETE FROM ep_role_notification using ep_role_notification inner join fn_role 
		where fn_role.app_id=:app_id and ep_role_notification.role_id= fn_role.role_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove all records from fn_role that is associated with this app-->
	<sql-query name="removeAppFromFnRole">	
		<![CDATA[
		DELETE FROM fn_role where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove app contact us entries that is associated with this app-->
	<sql-query name="removeAppFromAppContactUs">	
		<![CDATA[
		DELETE FROM fn_app_contact_us where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove app personalization entries that is associated with this app-->
	<sql-query name="removeAppFromEpPersUserAppSel">	
		<![CDATA[
		DELETE FROM fn_pers_user_app_sel where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove app personalization sorting entries that is associated with this app-->
	<sql-query name="removeAppFromEpPersUserAppManSort">	
		<![CDATA[
		DELETE FROM ep_pers_user_app_man_sort where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove rows from user role request table entries that is associated with this app-->
	<sql-query name="removeAppFromEpUserRolesRequest">	
		<![CDATA[
		DELETE FROM ep_user_roles_request where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove rows from web analytics table entries that is associated with this app-->
	<sql-query name="removeAppFromEpWebAnalytics">	
		<![CDATA[
		DELETE FROM ep_web_analytics_source where app_id=:app_id
		;
 		]]>
	</sql-query>
	
	<!-- Remove row from fn app table -->
	<sql-query name="removeAppFromFnApp">	
		<![CDATA[
		DELETE FROM fn_app where app_id=:app_id
		;
 		]]>
	</sql-query>


	<query name="getBasicauthAccount">
      select id,password from BasicAuthCredentials
    </query>
    
     <query name="getMicroserviceInfo">
      select id,password from MicroserviceData
    </query>
	
	<sql-query name="getUserRoleOnUserIdAndRoleIdAndAppId">	
		<return alias="getUserRoleOnUserIdAndRoleIdAndAppId" class="org.onap.portalapp.portal.domain.EPUserApp" />   	
		<![CDATA[
 		select * from fn_user_role where user_id= :userId 
 		and role_id= :roleId 
 		and app_id= :appId
 		; 
 		]]>
	</sql-query>

	<sql-query name="userAppGlobalRoles">
		<return alias="userAppGlobalRoles"
			class="org.onap.portalapp.portal.domain.EPRole" />
       <![CDATA[ 
        select fr.role_id , fr.role_name ,fr.active_yn, fr.priority, fr.app_id, fr.app_role_id 
        from fn_user_role a, fn_role fr, fn_user fu 
        where a.role_id in (select b.role_id from ep_app_role_function b where b.role_app_id = 1 and b.app_id =:appId) and a.user_id =fu.user_id and a.role_id = fr.role_id and fr.active_yn='Y' and fu.active_yn='Y' and fu.user_id =:userId
        ;             
       ]]>
	</sql-query>

	<sql-query name="getAllCentralizedAppsRoles">
		<return alias="allCentralizedAppsRoles"
			class="org.onap.portalapp.portal.transport.CentralizedAppRoles" />
       <![CDATA[ 
        select distinct fa.app_id, fa.auth_namespace, fr.role_name, fr.role_id from fn_app fa,  fn_role fr where fa.auth_central = 'Y' and fa.auth_namespace is not null
 		and (fa.app_id = fr.app_id or COALESCE(fr.app_id,1) = fa.app_id) and fr.active_yn = 'Y' order by fa.app_id ;          
       ]]>
	</sql-query>

	<sql-query name="getUserCentralizedAppRoles">
		<return alias="userCentralizedAppRoles"
			class="org.onap.portalapp.portal.transport.CentralizedAppRoles" />
       <![CDATA[ 
		select distinct fur.app_id, fa.auth_namespace, fr.role_name, fur.role_id from fn_user_role fur, fn_app fa, fn_role fr, fn_user fu 
		where fa.app_id = fur.app_id 
		and fr.role_id = fur.role_id
		and fu.user_id = fur.user_id 
		and fu.ORG_USER_ID = :orgUserId
		and fa.auth_namespace is not null
		and fr.active_yn = 'Y'
		order by role_id;
		]]>
	</sql-query>
	<sql-query name="getAprroverRoleFunctionsOfUser">
		<![CDATA[
		select distinct ep.function_cd from fn_user_role fu, ep_app_role_function ep, ep_app_function ea
		where fu.role_id = ep.role_id
		and fu.app_id = ep.app_id
		and fu.user_id =:userId
		and ea.function_cd = ep.function_cd and ea.function_cd like 'approver|%'
		and exists
		(
		select fa.app_id from fn_user fu, fn_user_role ur, fn_app fa where fu.user_id =:userId and fu.user_id = ur.user_id
		and ur.app_id = fa.app_id and fa.enabled = 'Y'
		);
		]]>
</sql-query>
<sql-query name="getUserApproverRoles">
		<![CDATA[
		select distinct fr.role_name from fn_user_role fu, ep_app_role_function ep, ep_app_function ea, fn_role fr
		where fu.role_id = ep.role_id
		and fu.app_id = ep.app_id
		and fu.user_id = :userId
		and fu.role_id = fr.role_id and fr.active_yn='Y'
		and ea.function_cd = ep.function_cd and ea.function_cd like 'approver|%'
		and exists
		(
		select fa.app_id from fn_user fu, fn_user_role ur, fn_app fa where fu.user_id =:userId and fu.user_id = ur.user_id
		and ur.app_id = fa.app_id and fa.enabled = 'Y'
		);
		]]>
</sql-query>
<sql-query name="getAdminAppsForTheUser">
		<![CDATA[
		select fa.app_id  from fn_user_role ur,fn_app fa where ur.user_id =:userId and ur.app_id=fa.app_id and ur.role_id= 999 and (fa.enabled = 'Y' || fa.app_id=1)

	
		]]>
</sql-query>


<sql-query name="getUserRoleOnUserIdAndAppId">	
		<return alias="getUserRoleOnUserIdAndAppId" class="org.onap.portalapp.portal.domain.EPRole" />   	
		<![CDATA[
		
		select fr.role_id , fr.role_name ,fr.active_yn, fr.priority, fr.app_id, fr.app_role_id  FROM fn_role fr, fn_user_role fur WHERE fr.role_id = fur.role_id AND fur.user_id= :userId AND fur.app_id = :appId AND fr.active_yn='Y'
 		
 		]]>
	</sql-query>
	
	<sql-query name="getAllAdminAppsofTheUser">
		<![CDATA[
		select fa.app_id  from fn_user_role ur,fn_app fa where ur.user_id =:userId and ur.app_id=fa.app_id and ur.role_id= 999

		]]>
    </sql-query>
	<sql-query name="getAllAppsFunctionsOfUser">
			<![CDATA[
			select distinct ep.function_cd from fn_user_role fu, ep_app_role_function ep, ep_app_function ea, fn_app fa , fn_role fr
			where fu.role_id = ep.role_id 
			and fu.app_id = ep.app_id
			and fu.user_id =:userId
			and ea.function_cd = ep.function_cd
            and ((fu.app_id = fa.app_id  and fa.enabled = 'Y' ) or (fa.app_id = 1))
            and fr.role_id = fu.role_id and fr.active_yn='Y' 
		    union
            select distinct app_r_f.function_cd from ep_app_role_function app_r_f, ep_app_function a_f
			where role_id = 999
			and app_r_f.function_cd = a_f.function_cd
			and exists
			(
			select fa.app_id from fn_user fu, fn_user_role ur, fn_app fa where fu.user_id =:userId and fu.user_id = ur.user_id
			and ur.role_id = 999 and ur.app_id = fa.app_id and fa.enabled = 'Y'
			);
			]]>
	</sql-query>
	<sql-query name="updateFnUser">
		<![CDATA[
			UPDATE fn_user fu SET fu.language_id=:language_id WHERE fu.login_id=:login_id
		]]>
	</sql-query>
</hibernate-mapping>
